# 信号（signal）

## 1. 概念和概述

1. 信号是事件发生时对进程的通知机制，又称作软件中断。

2. 信号打断了程序执行的正常流程。

3. 一个具有合适权限的进程能够向另一个进程发送信号，这一用法可以作为一种同步技术，甚至是进程间通信（IPC）的原始形式。

4. 进程也可以向自身发送信号。

5. 发送往进程大信号大多数来自于内核，引发内核为进程产生信号的各类事件如下

    + 硬件发生异常
    + 用户键入了能够产生信号的终端特殊字符。
    + 发生了软件事件
6. 针对每个信号，都定义了一个唯一的整数，从1开始顺序展开，<signal.h>以SIGxxxx形式的符号名对这些整数做了定义。

7. 由于每个信号的实际编号随系统实现的不同而不同，应当总是在代码中使用这些符号名。

8. 信号分为两大类。

    1. 第一组信号用于内核向进程通知事件，构成标准信号（Standard Signal）。Linux中标准信号的编号为1～31。

    2. 第二组信号用于弥补标准信号的诸多限制，构成实时信号（Real Time Signal）。实时信号有以下优势：
        + 实时信号的范围有所扩大，可应用于应用程序自定义的目的，而标准信号中可供随意使用的只有SIGUSR1和SIGUSR2。
        + 对实时信号采取队列化管理。
        + 当发送一个实时信号时，可以为信号指定伴随数据，供接收进程的信号处理函数获取。
        + 不同实时信号的传递顺序得到保障，率先传递具有最小编号的信号。

9. 信号因某些事件而产生，信号产生后，会被稍后传递给某一进程，进程也会采取一些措施来处理信号，在产生和到达期间信号处于等待（Pending）状态。

10. 通常来说，一旦内核接下来要调度该进程运行，等待信号会马上到达，或者进程正在运行，也会立即传递信号。

11. 有时需要确保一段代码不被传递来的信号打断，可以将信号添加到进程的信号掩码中，达到阻塞改组信号到达的目的，如果所产生的信号处在阻塞之列，那么信号将保持等待状态，直到对其接触阻塞（从信号掩码中移除），进程可以使用各种系统调用为信号掩码添加或删除信号。

12. 信号到达后，进程视具体信号执行如下默认操作之一：

    + 忽略信号，内核将信号丢弃。
    + 终止进程（指因异常而终止，而非调用exit()正常终止）。
    + 产生核心转储文件，并且终止进程。
    + 停止进程。
    + 于之前暂停进程后再度恢复进程的执行。

13. 除了根据特定的信号采取默认行为外，程序也能改变信号到达时的响应行为，也称之为对信号的处置（disposition）设置。
    + 采取默认行为，适用于撤销之前对信号处置的修改，恢复默认处置场景。
    + 忽略信号，适用于默认行为终止进程的信号。
    + 执行信号处理程序。

14. 信号处理程序由程序员编写，用于响应传递来的信号而执行适当的任务。

15. 无法将信号处置设置为终止进程或者转储核心。效果近似的是在信号处理函数内调用exit()或者abort()。

16. 信号类型及默认行为的信息详见<signal.h>或者手册。

## 2. 改变信号的处置

### UNIX系统提供了两种方法改变信号的处置，signal()和sigaction()。

#### **signal()**

``` C
#include <signal.h>

void ( *signal(int sig, void (*handler)(int)) )(int);
```

1. 如果设置信号处理函数成功，返回指向之前信号处理函数的指针，反之函数返回SIG_ERR。

2. 第一个参数sig表示希望处置的信号的编号，第二个参数handler表示信号处置函数的地址。这个信号处置函数没有返回值，有一个整形的参数表示希望处置的信号。

3. 信号处置函数一般具有以下形式：

    ``` C
    void handler(int sig)
    {
        /* code for the handler */
    }
    ```

4. 使用signal()将无法在不改变信号处置的同时获取到当前的信号处置。想要达到这一点必须使用sigaction()。

5. 对信号处理函数指针类型作如下定义，有助于理解signal()的原型。

    ``` C
    typedef void ( *sighandler_t)(int);

    sighandler_t signal(int sig, sighandler_t handler);
    ```

6. 如果定义了_GNU_SOURCE宏，就可以使用glibc中暴露的非标准sighandler_t数据类型。

7. 在为signal()制定handler参数时，可以使用SIG_DEL和SIG_IGN代替函数地址。

    + SIG_DEL将信号处置重置为默认值。
    + SIG_IGN将忽略信号。

## 3. 信号处理器

1. 信号处理程序（信号捕捉器）是指信号传递给进程时会调用的一个函数。

2. 调用信号处理程序时，可能会打断主程序的流程，内核代表进程来调研信号处理程序。

3. 当信号处理函数返回后，主程序会从中断位置恢复执行。

4. 信号处理程序设计应当力求简单。

5. 内核在调用信号处理程序时，会将引发调用的信号作为一个整形参数传递给信号处理函数，对于只处理一种信号的信号处理函数来说，这个参数毫无用处，但是对于处理多种信号的信号处理函数来说，这个参数可以用来辨别信号类型。

## 4. 发送信号：kill()

``` C
#include <signal.h>

int kill(pid_t pid, int sig);

Returns 0 on success, or -1 on error
```

1. pid参数表示一个或多个进程，sig指定了要发送的信号，如何解释pid，视以下四种情况而定。
    + pid  >  0：发送信号给pid指定的进程。
    + pid  == 0：发送信号给调用进程同组的每个进程，包括调用进程自身。
    + pid  < -1：向组ID等于pid绝对值的进程组内所有下属进程发送信号。
    + pis == -1：信号的发送范围是调用进程有权将信号发往的每个目标进程，除去（init和systemed）和调用进程自身。
2. 如果不满足上述的四种情况，kill()将调用失败，同时将errno置为ESRCH（查无此进程）

3. 进程发送给另一进程还需要有适当的权限。
    + 特权级进程可以向任何进程发送信号。
    + 以root用户和组运行的init进程或者systemed进程（pid = 1）是一种特例，仅能接收已经安装了信号处理函数的信号。防止系统管理员关闭init进程或systemed进程，因为init和systemed是系统运行的基石。（init已经逐渐被 systemed替换）。
    + SIGCONT做特殊处理，无论对用户ID的权限检查结果如何，非特权进程可以向统一会话中的统一进程发送这个信号。

4. 如果进程无权发送信号给pid指定的进程，kill()将调用失败，并且将errno设置为EPERM，若pid指定的是一个进程组，只要成功向进程组中的一个进程成功发送信号，则kill()调用成功。

5. kill()还可以用来检查进程是否存在，若将sig设置为0（空信号），则kill()只会进行错误检查，查看是否有进程可以发送信号。

## 5. 使用raise()和killpg()发送信号

``` C
#include <signal.h>

int raise(int sig);
Return 0 on success, or nonzero on error

int killpg(pid_t pgrp, int sig);
return 0 on success. or -1 on error

```

1. 在单线程程序中，raise(sig)相当于kill(getpid(), sig)。

2. 在支持多线程的系统中会将raise实现为pthread_kill(pthread_self(), sig)。

3. 在调用raise或者kill向自身发送信号时，信号立即传递。

4. 调用raise唯一可能发生的错误为EINVAL。

5. killpg向pgrp指定的进程组内所有成员发送一个信号。

6. killpg(pgrp, sig)相当于kill(-grpg, sig)。